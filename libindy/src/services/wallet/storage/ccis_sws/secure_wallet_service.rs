// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `secure_wallet_service.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct EncryptedTagResponse {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    pub encryptedValue: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptedTagResponse {
    fn default() -> &'a EncryptedTagResponse {
        <EncryptedTagResponse as ::protobuf::Message>::default_instance()
    }
}

impl EncryptedTagResponse {
    pub fn new() -> EncryptedTagResponse {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }

    // bytes encryptedValue = 2;


    pub fn get_encryptedValue(&self) -> &[u8] {
        &self.encryptedValue
    }
    pub fn clear_encryptedValue(&mut self) {
        self.encryptedValue.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryptedValue(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryptedValue = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptedValue(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encryptedValue
    }

    // Take field
    pub fn take_encryptedValue(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encryptedValue, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EncryptedTagResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encryptedValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        if !self.encryptedValue.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.encryptedValue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        if !self.encryptedValue.is_empty() {
            os.write_bytes(2, &self.encryptedValue)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedTagResponse {
        EncryptedTagResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "name",
                    |m: &EncryptedTagResponse| { &m.name },
                    |m: &mut EncryptedTagResponse| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encryptedValue",
                    |m: &EncryptedTagResponse| { &m.encryptedValue },
                    |m: &mut EncryptedTagResponse| { &mut m.encryptedValue },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncryptedTagResponse>(
                    "EncryptedTagResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptedTagResponse {
        static mut instance: ::protobuf::lazy::Lazy<EncryptedTagResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncryptedTagResponse,
        };
        unsafe {
            instance.get(EncryptedTagResponse::new)
        }
    }
}

impl ::protobuf::Clear for EncryptedTagResponse {
    fn clear(&mut self) {
        self.name.clear();
        self.encryptedValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedTagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedTagResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlaintextTagResponse {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    pub plaintextValue: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlaintextTagResponse {
    fn default() -> &'a PlaintextTagResponse {
        <PlaintextTagResponse as ::protobuf::Message>::default_instance()
    }
}

impl PlaintextTagResponse {
    pub fn new() -> PlaintextTagResponse {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }

    // string plaintextValue = 2;


    pub fn get_plaintextValue(&self) -> &str {
        &self.plaintextValue
    }
    pub fn clear_plaintextValue(&mut self) {
        self.plaintextValue.clear();
    }

    // Param is passed by value, moved
    pub fn set_plaintextValue(&mut self, v: ::std::string::String) {
        self.plaintextValue = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plaintextValue(&mut self) -> &mut ::std::string::String {
        &mut self.plaintextValue
    }

    // Take field
    pub fn take_plaintextValue(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.plaintextValue, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PlaintextTagResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.plaintextValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        if !self.plaintextValue.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.plaintextValue);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        if !self.plaintextValue.is_empty() {
            os.write_string(2, &self.plaintextValue)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlaintextTagResponse {
        PlaintextTagResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "name",
                    |m: &PlaintextTagResponse| { &m.name },
                    |m: &mut PlaintextTagResponse| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "plaintextValue",
                    |m: &PlaintextTagResponse| { &m.plaintextValue },
                    |m: &mut PlaintextTagResponse| { &mut m.plaintextValue },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlaintextTagResponse>(
                    "PlaintextTagResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlaintextTagResponse {
        static mut instance: ::protobuf::lazy::Lazy<PlaintextTagResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlaintextTagResponse,
        };
        unsafe {
            instance.get(PlaintextTagResponse::new)
        }
    }
}

impl ::protobuf::Clear for PlaintextTagResponse {
    fn clear(&mut self) {
        self.name.clear();
        self.plaintextValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlaintextTagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaintextTagResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletItemResponse {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub key: ::std::vec::Vec<u8>,
    pub field_type: ::std::vec::Vec<u8>,
    pub encryptedTags: ::protobuf::RepeatedField<EncryptedTagResponse>,
    pub plaintextTags: ::protobuf::RepeatedField<PlaintextTagResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletItemResponse {
    fn default() -> &'a WalletItemResponse {
        <WalletItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl WalletItemResponse {
    pub fn new() -> WalletItemResponse {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes type = 4;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // repeated .routeguide.EncryptedTagResponse encryptedTags = 5;


    pub fn get_encryptedTags(&self) -> &[EncryptedTagResponse] {
        &self.encryptedTags
    }
    pub fn clear_encryptedTags(&mut self) {
        self.encryptedTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryptedTags(&mut self, v: ::protobuf::RepeatedField<EncryptedTagResponse>) {
        self.encryptedTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryptedTags(&mut self) -> &mut ::protobuf::RepeatedField<EncryptedTagResponse> {
        &mut self.encryptedTags
    }

    // Take field
    pub fn take_encryptedTags(&mut self) -> ::protobuf::RepeatedField<EncryptedTagResponse> {
        ::std::mem::replace(&mut self.encryptedTags, ::protobuf::RepeatedField::new())
    }

    // repeated .routeguide.PlaintextTagResponse plaintextTags = 6;


    pub fn get_plaintextTags(&self) -> &[PlaintextTagResponse] {
        &self.plaintextTags
    }
    pub fn clear_plaintextTags(&mut self) {
        self.plaintextTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_plaintextTags(&mut self, v: ::protobuf::RepeatedField<PlaintextTagResponse>) {
        self.plaintextTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plaintextTags(&mut self) -> &mut ::protobuf::RepeatedField<PlaintextTagResponse> {
        &mut self.plaintextTags
    }

    // Take field
    pub fn take_plaintextTags(&mut self) -> ::protobuf::RepeatedField<PlaintextTagResponse> {
        ::std::mem::replace(&mut self.plaintextTags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WalletItemResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedTags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plaintextTags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryptedTags)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plaintextTags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.key);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.field_type);
        }
        for value in &self.encryptedTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.plaintextTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(3, &self.key)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(4, &self.field_type)?;
        }
        for v in &self.encryptedTags {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.plaintextTags {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletItemResponse {
        WalletItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &WalletItemResponse| { &m.id },
                    |m: &mut WalletItemResponse| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &WalletItemResponse| { &m.value },
                    |m: &mut WalletItemResponse| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &WalletItemResponse| { &m.key },
                    |m: &mut WalletItemResponse| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &WalletItemResponse| { &m.field_type },
                    |m: &mut WalletItemResponse| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedTagResponse>>(
                    "encryptedTags",
                    |m: &WalletItemResponse| { &m.encryptedTags },
                    |m: &mut WalletItemResponse| { &mut m.encryptedTags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlaintextTagResponse>>(
                    "plaintextTags",
                    |m: &WalletItemResponse| { &m.plaintextTags },
                    |m: &mut WalletItemResponse| { &mut m.plaintextTags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WalletItemResponse>(
                    "WalletItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<WalletItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletItemResponse,
        };
        unsafe {
            instance.get(WalletItemResponse::new)
        }
    }
}

impl ::protobuf::Clear for WalletItemResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.value.clear();
        self.key.clear();
        self.field_type.clear();
        self.encryptedTags.clear();
        self.plaintextTags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateWalletRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub metadata: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateWalletRequest {
    fn default() -> &'a CreateWalletRequest {
        <CreateWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateWalletRequest {
    pub fn new() -> CreateWalletRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes metadata = 2;


    pub fn get_metadata(&self) -> &[u8] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.metadata, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreateWalletRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.metadata.is_empty() {
            os.write_bytes(2, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateWalletRequest {
        CreateWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &CreateWalletRequest| { &m.walletId },
                    |m: &mut CreateWalletRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "metadata",
                    |m: &CreateWalletRequest| { &m.metadata },
                    |m: &mut CreateWalletRequest| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateWalletRequest>(
                    "CreateWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateWalletRequest,
        };
        unsafe {
            instance.get(CreateWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateWalletRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateWalletResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateWalletResponse {
    fn default() -> &'a CreateWalletResponse {
        <CreateWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateWalletResponse {
    pub fn new() -> CreateWalletResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateWalletResponse {
        CreateWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &CreateWalletResponse| { &m.message },
                    |m: &mut CreateWalletResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateWalletResponse>(
                    "CreateWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateWalletResponse,
        };
        unsafe {
            instance.get(CreateWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateWalletResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletRequest {
    // message fields
    pub walletId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletRequest {
    fn default() -> &'a DeleteWalletRequest {
        <DeleteWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletRequest {
    pub fn new() -> DeleteWalletRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWalletRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletRequest {
        DeleteWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &DeleteWalletRequest| { &m.walletId },
                    |m: &mut DeleteWalletRequest| { &mut m.walletId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletRequest>(
                    "DeleteWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletRequest,
        };
        unsafe {
            instance.get(DeleteWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletResponse {
    fn default() -> &'a DeleteWalletResponse {
        <DeleteWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletResponse {
    pub fn new() -> DeleteWalletResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletResponse {
        DeleteWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &DeleteWalletResponse| { &m.message },
                    |m: &mut DeleteWalletResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletResponse>(
                    "DeleteWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletResponse,
        };
        unsafe {
            instance.get(DeleteWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletExistsRequest {
    // message fields
    pub walletId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletExistsRequest {
    fn default() -> &'a WalletExistsRequest {
        <WalletExistsRequest as ::protobuf::Message>::default_instance()
    }
}

impl WalletExistsRequest {
    pub fn new() -> WalletExistsRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WalletExistsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletExistsRequest {
        WalletExistsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &WalletExistsRequest| { &m.walletId },
                    |m: &mut WalletExistsRequest| { &mut m.walletId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WalletExistsRequest>(
                    "WalletExistsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletExistsRequest {
        static mut instance: ::protobuf::lazy::Lazy<WalletExistsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletExistsRequest,
        };
        unsafe {
            instance.get(WalletExistsRequest::new)
        }
    }
}

impl ::protobuf::Clear for WalletExistsRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletExistsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletExistsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WalletExistsResponse {
    // message fields
    pub exists: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WalletExistsResponse {
    fn default() -> &'a WalletExistsResponse {
        <WalletExistsResponse as ::protobuf::Message>::default_instance()
    }
}

impl WalletExistsResponse {
    pub fn new() -> WalletExistsResponse {
        ::std::default::Default::default()
    }

    // bool exists = 1;


    pub fn get_exists(&self) -> bool {
        self.exists
    }
    pub fn clear_exists(&mut self) {
        self.exists = false;
    }

    // Param is passed by value, moved
    pub fn set_exists(&mut self, v: bool) {
        self.exists = v;
    }
}

impl ::protobuf::Message for WalletExistsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exists = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.exists != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.exists != false {
            os.write_bool(1, self.exists)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WalletExistsResponse {
        WalletExistsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "exists",
                    |m: &WalletExistsResponse| { &m.exists },
                    |m: &mut WalletExistsResponse| { &mut m.exists },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WalletExistsResponse>(
                    "WalletExistsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WalletExistsResponse {
        static mut instance: ::protobuf::lazy::Lazy<WalletExistsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WalletExistsResponse,
        };
        unsafe {
            instance.get(WalletExistsResponse::new)
        }
    }
}

impl ::protobuf::Clear for WalletExistsResponse {
    fn clear(&mut self) {
        self.exists = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WalletExistsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WalletExistsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWalletItemRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWalletItemRequest {
    fn default() -> &'a GetWalletItemRequest {
        <GetWalletItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWalletItemRequest {
    pub fn new() -> GetWalletItemRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetWalletItemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWalletItemRequest {
        GetWalletItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &GetWalletItemRequest| { &m.walletId },
                    |m: &mut GetWalletItemRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &GetWalletItemRequest| { &m.field_type },
                    |m: &mut GetWalletItemRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &GetWalletItemRequest| { &m.id },
                    |m: &mut GetWalletItemRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetWalletItemRequest>(
                    "GetWalletItemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetWalletItemRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetWalletItemRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetWalletItemRequest,
        };
        unsafe {
            instance.get(GetWalletItemRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetWalletItemRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWalletItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWalletItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWalletItemResponse {
    // message fields
    pub walletItem: ::protobuf::SingularPtrField<WalletItemResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWalletItemResponse {
    fn default() -> &'a GetWalletItemResponse {
        <GetWalletItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetWalletItemResponse {
    pub fn new() -> GetWalletItemResponse {
        ::std::default::Default::default()
    }

    // .routeguide.WalletItemResponse walletItem = 1;


    pub fn get_walletItem(&self) -> &WalletItemResponse {
        self.walletItem.as_ref().unwrap_or_else(|| WalletItemResponse::default_instance())
    }
    pub fn clear_walletItem(&mut self) {
        self.walletItem.clear();
    }

    pub fn has_walletItem(&self) -> bool {
        self.walletItem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_walletItem(&mut self, v: WalletItemResponse) {
        self.walletItem = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletItem(&mut self) -> &mut WalletItemResponse {
        if self.walletItem.is_none() {
            self.walletItem.set_default();
        }
        self.walletItem.as_mut().unwrap()
    }

    // Take field
    pub fn take_walletItem(&mut self) -> WalletItemResponse {
        self.walletItem.take().unwrap_or_else(|| WalletItemResponse::new())
    }
}

impl ::protobuf::Message for GetWalletItemResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.walletItem {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.walletItem)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.walletItem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.walletItem.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWalletItemResponse {
        GetWalletItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WalletItemResponse>>(
                    "walletItem",
                    |m: &GetWalletItemResponse| { &m.walletItem },
                    |m: &mut GetWalletItemResponse| { &mut m.walletItem },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetWalletItemResponse>(
                    "GetWalletItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetWalletItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetWalletItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetWalletItemResponse,
        };
        unsafe {
            instance.get(GetWalletItemResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetWalletItemResponse {
    fn clear(&mut self) {
        self.walletItem.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWalletItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWalletItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddWalletItemRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub key: ::std::vec::Vec<u8>,
    pub encryptedTags: ::protobuf::RepeatedField<EncryptedTagResponse>,
    pub plaintextTags: ::protobuf::RepeatedField<PlaintextTagResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddWalletItemRequest {
    fn default() -> &'a AddWalletItemRequest {
        <AddWalletItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddWalletItemRequest {
    pub fn new() -> AddWalletItemRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // bytes value = 4;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes key = 5;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // repeated .routeguide.EncryptedTagResponse encryptedTags = 6;


    pub fn get_encryptedTags(&self) -> &[EncryptedTagResponse] {
        &self.encryptedTags
    }
    pub fn clear_encryptedTags(&mut self) {
        self.encryptedTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryptedTags(&mut self, v: ::protobuf::RepeatedField<EncryptedTagResponse>) {
        self.encryptedTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryptedTags(&mut self) -> &mut ::protobuf::RepeatedField<EncryptedTagResponse> {
        &mut self.encryptedTags
    }

    // Take field
    pub fn take_encryptedTags(&mut self) -> ::protobuf::RepeatedField<EncryptedTagResponse> {
        ::std::mem::replace(&mut self.encryptedTags, ::protobuf::RepeatedField::new())
    }

    // repeated .routeguide.PlaintextTagResponse plaintextTags = 7;


    pub fn get_plaintextTags(&self) -> &[PlaintextTagResponse] {
        &self.plaintextTags
    }
    pub fn clear_plaintextTags(&mut self) {
        self.plaintextTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_plaintextTags(&mut self, v: ::protobuf::RepeatedField<PlaintextTagResponse>) {
        self.plaintextTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plaintextTags(&mut self) -> &mut ::protobuf::RepeatedField<PlaintextTagResponse> {
        &mut self.plaintextTags
    }

    // Take field
    pub fn take_plaintextTags(&mut self) -> ::protobuf::RepeatedField<PlaintextTagResponse> {
        ::std::mem::replace(&mut self.plaintextTags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddWalletItemRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedTags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plaintextTags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryptedTags)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plaintextTags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.key);
        }
        for value in &self.encryptedTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.plaintextTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(5, &self.key)?;
        }
        for v in &self.encryptedTags {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.plaintextTags {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddWalletItemRequest {
        AddWalletItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &AddWalletItemRequest| { &m.walletId },
                    |m: &mut AddWalletItemRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &AddWalletItemRequest| { &m.field_type },
                    |m: &mut AddWalletItemRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &AddWalletItemRequest| { &m.id },
                    |m: &mut AddWalletItemRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &AddWalletItemRequest| { &m.value },
                    |m: &mut AddWalletItemRequest| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &AddWalletItemRequest| { &m.key },
                    |m: &mut AddWalletItemRequest| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedTagResponse>>(
                    "encryptedTags",
                    |m: &AddWalletItemRequest| { &m.encryptedTags },
                    |m: &mut AddWalletItemRequest| { &mut m.encryptedTags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlaintextTagResponse>>(
                    "plaintextTags",
                    |m: &AddWalletItemRequest| { &m.plaintextTags },
                    |m: &mut AddWalletItemRequest| { &mut m.plaintextTags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddWalletItemRequest>(
                    "AddWalletItemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddWalletItemRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddWalletItemRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddWalletItemRequest,
        };
        unsafe {
            instance.get(AddWalletItemRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddWalletItemRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.value.clear();
        self.key.clear();
        self.encryptedTags.clear();
        self.plaintextTags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddWalletItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddWalletItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddWalletItemResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddWalletItemResponse {
    fn default() -> &'a AddWalletItemResponse {
        <AddWalletItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddWalletItemResponse {
    pub fn new() -> AddWalletItemResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddWalletItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddWalletItemResponse {
        AddWalletItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &AddWalletItemResponse| { &m.message },
                    |m: &mut AddWalletItemResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddWalletItemResponse>(
                    "AddWalletItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddWalletItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddWalletItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddWalletItemResponse,
        };
        unsafe {
            instance.get(AddWalletItemResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddWalletItemResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddWalletItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddWalletItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateWalletItemRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateWalletItemRequest {
    fn default() -> &'a UpdateWalletItemRequest {
        <UpdateWalletItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateWalletItemRequest {
    pub fn new() -> UpdateWalletItemRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // bytes value = 4;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // bytes key = 5;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UpdateWalletItemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(5, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateWalletItemRequest {
        UpdateWalletItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &UpdateWalletItemRequest| { &m.walletId },
                    |m: &mut UpdateWalletItemRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &UpdateWalletItemRequest| { &m.field_type },
                    |m: &mut UpdateWalletItemRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &UpdateWalletItemRequest| { &m.id },
                    |m: &mut UpdateWalletItemRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &UpdateWalletItemRequest| { &m.value },
                    |m: &mut UpdateWalletItemRequest| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &UpdateWalletItemRequest| { &m.key },
                    |m: &mut UpdateWalletItemRequest| { &mut m.key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateWalletItemRequest>(
                    "UpdateWalletItemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateWalletItemRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateWalletItemRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateWalletItemRequest,
        };
        unsafe {
            instance.get(UpdateWalletItemRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateWalletItemRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.value.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateWalletItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateWalletItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateWalletItemResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateWalletItemResponse {
    fn default() -> &'a UpdateWalletItemResponse {
        <UpdateWalletItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateWalletItemResponse {
    pub fn new() -> UpdateWalletItemResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateWalletItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateWalletItemResponse {
        UpdateWalletItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &UpdateWalletItemResponse| { &m.message },
                    |m: &mut UpdateWalletItemResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateWalletItemResponse>(
                    "UpdateWalletItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateWalletItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdateWalletItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateWalletItemResponse,
        };
        unsafe {
            instance.get(UpdateWalletItemResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdateWalletItemResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateWalletItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateWalletItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddWalletItemTagsRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    pub encryptedTags: ::protobuf::RepeatedField<EncryptedTagResponse>,
    pub plaintextTags: ::protobuf::RepeatedField<PlaintextTagResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddWalletItemTagsRequest {
    fn default() -> &'a AddWalletItemTagsRequest {
        <AddWalletItemTagsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddWalletItemTagsRequest {
    pub fn new() -> AddWalletItemTagsRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // repeated .routeguide.EncryptedTagResponse encryptedTags = 4;


    pub fn get_encryptedTags(&self) -> &[EncryptedTagResponse] {
        &self.encryptedTags
    }
    pub fn clear_encryptedTags(&mut self) {
        self.encryptedTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryptedTags(&mut self, v: ::protobuf::RepeatedField<EncryptedTagResponse>) {
        self.encryptedTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryptedTags(&mut self) -> &mut ::protobuf::RepeatedField<EncryptedTagResponse> {
        &mut self.encryptedTags
    }

    // Take field
    pub fn take_encryptedTags(&mut self) -> ::protobuf::RepeatedField<EncryptedTagResponse> {
        ::std::mem::replace(&mut self.encryptedTags, ::protobuf::RepeatedField::new())
    }

    // repeated .routeguide.PlaintextTagResponse plaintextTags = 5;


    pub fn get_plaintextTags(&self) -> &[PlaintextTagResponse] {
        &self.plaintextTags
    }
    pub fn clear_plaintextTags(&mut self) {
        self.plaintextTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_plaintextTags(&mut self, v: ::protobuf::RepeatedField<PlaintextTagResponse>) {
        self.plaintextTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plaintextTags(&mut self) -> &mut ::protobuf::RepeatedField<PlaintextTagResponse> {
        &mut self.plaintextTags
    }

    // Take field
    pub fn take_plaintextTags(&mut self) -> ::protobuf::RepeatedField<PlaintextTagResponse> {
        ::std::mem::replace(&mut self.plaintextTags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddWalletItemTagsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedTags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plaintextTags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryptedTags)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plaintextTags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        for value in &self.encryptedTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.plaintextTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        for v in &self.encryptedTags {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.plaintextTags {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddWalletItemTagsRequest {
        AddWalletItemTagsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &AddWalletItemTagsRequest| { &m.walletId },
                    |m: &mut AddWalletItemTagsRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &AddWalletItemTagsRequest| { &m.field_type },
                    |m: &mut AddWalletItemTagsRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &AddWalletItemTagsRequest| { &m.id },
                    |m: &mut AddWalletItemTagsRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedTagResponse>>(
                    "encryptedTags",
                    |m: &AddWalletItemTagsRequest| { &m.encryptedTags },
                    |m: &mut AddWalletItemTagsRequest| { &mut m.encryptedTags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlaintextTagResponse>>(
                    "plaintextTags",
                    |m: &AddWalletItemTagsRequest| { &m.plaintextTags },
                    |m: &mut AddWalletItemTagsRequest| { &mut m.plaintextTags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddWalletItemTagsRequest>(
                    "AddWalletItemTagsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddWalletItemTagsRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddWalletItemTagsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddWalletItemTagsRequest,
        };
        unsafe {
            instance.get(AddWalletItemTagsRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddWalletItemTagsRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.encryptedTags.clear();
        self.plaintextTags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddWalletItemTagsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddWalletItemTagsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddWalletItemTagsResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddWalletItemTagsResponse {
    fn default() -> &'a AddWalletItemTagsResponse {
        <AddWalletItemTagsResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddWalletItemTagsResponse {
    pub fn new() -> AddWalletItemTagsResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddWalletItemTagsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddWalletItemTagsResponse {
        AddWalletItemTagsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &AddWalletItemTagsResponse| { &m.message },
                    |m: &mut AddWalletItemTagsResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddWalletItemTagsResponse>(
                    "AddWalletItemTagsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddWalletItemTagsResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddWalletItemTagsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddWalletItemTagsResponse,
        };
        unsafe {
            instance.get(AddWalletItemTagsResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddWalletItemTagsResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddWalletItemTagsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddWalletItemTagsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateWalletItemTagsRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    pub encryptedTags: ::protobuf::RepeatedField<EncryptedTagResponse>,
    pub plaintextTags: ::protobuf::RepeatedField<PlaintextTagResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateWalletItemTagsRequest {
    fn default() -> &'a UpdateWalletItemTagsRequest {
        <UpdateWalletItemTagsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateWalletItemTagsRequest {
    pub fn new() -> UpdateWalletItemTagsRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // repeated .routeguide.EncryptedTagResponse encryptedTags = 4;


    pub fn get_encryptedTags(&self) -> &[EncryptedTagResponse] {
        &self.encryptedTags
    }
    pub fn clear_encryptedTags(&mut self) {
        self.encryptedTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_encryptedTags(&mut self, v: ::protobuf::RepeatedField<EncryptedTagResponse>) {
        self.encryptedTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encryptedTags(&mut self) -> &mut ::protobuf::RepeatedField<EncryptedTagResponse> {
        &mut self.encryptedTags
    }

    // Take field
    pub fn take_encryptedTags(&mut self) -> ::protobuf::RepeatedField<EncryptedTagResponse> {
        ::std::mem::replace(&mut self.encryptedTags, ::protobuf::RepeatedField::new())
    }

    // repeated .routeguide.PlaintextTagResponse plaintextTags = 5;


    pub fn get_plaintextTags(&self) -> &[PlaintextTagResponse] {
        &self.plaintextTags
    }
    pub fn clear_plaintextTags(&mut self) {
        self.plaintextTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_plaintextTags(&mut self, v: ::protobuf::RepeatedField<PlaintextTagResponse>) {
        self.plaintextTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_plaintextTags(&mut self) -> &mut ::protobuf::RepeatedField<PlaintextTagResponse> {
        &mut self.plaintextTags
    }

    // Take field
    pub fn take_plaintextTags(&mut self) -> ::protobuf::RepeatedField<PlaintextTagResponse> {
        ::std::mem::replace(&mut self.plaintextTags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdateWalletItemTagsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.encryptedTags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.plaintextTags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.encryptedTags)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.plaintextTags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        for value in &self.encryptedTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.plaintextTags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        for v in &self.encryptedTags {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.plaintextTags {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateWalletItemTagsRequest {
        UpdateWalletItemTagsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &UpdateWalletItemTagsRequest| { &m.walletId },
                    |m: &mut UpdateWalletItemTagsRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &UpdateWalletItemTagsRequest| { &m.field_type },
                    |m: &mut UpdateWalletItemTagsRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &UpdateWalletItemTagsRequest| { &m.id },
                    |m: &mut UpdateWalletItemTagsRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedTagResponse>>(
                    "encryptedTags",
                    |m: &UpdateWalletItemTagsRequest| { &m.encryptedTags },
                    |m: &mut UpdateWalletItemTagsRequest| { &mut m.encryptedTags },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PlaintextTagResponse>>(
                    "plaintextTags",
                    |m: &UpdateWalletItemTagsRequest| { &m.plaintextTags },
                    |m: &mut UpdateWalletItemTagsRequest| { &mut m.plaintextTags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateWalletItemTagsRequest>(
                    "UpdateWalletItemTagsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateWalletItemTagsRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateWalletItemTagsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateWalletItemTagsRequest,
        };
        unsafe {
            instance.get(UpdateWalletItemTagsRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateWalletItemTagsRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.encryptedTags.clear();
        self.plaintextTags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateWalletItemTagsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateWalletItemTagsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateWalletItemTagsResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateWalletItemTagsResponse {
    fn default() -> &'a UpdateWalletItemTagsResponse {
        <UpdateWalletItemTagsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateWalletItemTagsResponse {
    pub fn new() -> UpdateWalletItemTagsResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateWalletItemTagsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateWalletItemTagsResponse {
        UpdateWalletItemTagsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &UpdateWalletItemTagsResponse| { &m.message },
                    |m: &mut UpdateWalletItemTagsResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateWalletItemTagsResponse>(
                    "UpdateWalletItemTagsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateWalletItemTagsResponse {
        static mut instance: ::protobuf::lazy::Lazy<UpdateWalletItemTagsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateWalletItemTagsResponse,
        };
        unsafe {
            instance.get(UpdateWalletItemTagsResponse::new)
        }
    }
}

impl ::protobuf::Clear for UpdateWalletItemTagsResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateWalletItemTagsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateWalletItemTagsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletItemTagsRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    pub tagNames: ::protobuf::RepeatedField<DeleteWalletItemTagsRequest_TagName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletItemTagsRequest {
    fn default() -> &'a DeleteWalletItemTagsRequest {
        <DeleteWalletItemTagsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletItemTagsRequest {
    pub fn new() -> DeleteWalletItemTagsRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // repeated .routeguide.DeleteWalletItemTagsRequest.TagName tagNames = 4;


    pub fn get_tagNames(&self) -> &[DeleteWalletItemTagsRequest_TagName] {
        &self.tagNames
    }
    pub fn clear_tagNames(&mut self) {
        self.tagNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagNames(&mut self, v: ::protobuf::RepeatedField<DeleteWalletItemTagsRequest_TagName>) {
        self.tagNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagNames(&mut self) -> &mut ::protobuf::RepeatedField<DeleteWalletItemTagsRequest_TagName> {
        &mut self.tagNames
    }

    // Take field
    pub fn take_tagNames(&mut self) -> ::protobuf::RepeatedField<DeleteWalletItemTagsRequest_TagName> {
        ::std::mem::replace(&mut self.tagNames, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteWalletItemTagsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tagNames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tagNames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        for value in &self.tagNames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        for v in &self.tagNames {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletItemTagsRequest {
        DeleteWalletItemTagsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &DeleteWalletItemTagsRequest| { &m.walletId },
                    |m: &mut DeleteWalletItemTagsRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &DeleteWalletItemTagsRequest| { &m.field_type },
                    |m: &mut DeleteWalletItemTagsRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &DeleteWalletItemTagsRequest| { &m.id },
                    |m: &mut DeleteWalletItemTagsRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeleteWalletItemTagsRequest_TagName>>(
                    "tagNames",
                    |m: &DeleteWalletItemTagsRequest| { &m.tagNames },
                    |m: &mut DeleteWalletItemTagsRequest| { &mut m.tagNames },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletItemTagsRequest>(
                    "DeleteWalletItemTagsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletItemTagsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletItemTagsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletItemTagsRequest,
        };
        unsafe {
            instance.get(DeleteWalletItemTagsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletItemTagsRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.tagNames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletItemTagsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletItemTagsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletItemTagsRequest_TagName {
    // message fields
    pub tagType: DeleteWalletItemTagsRequest_TagType,
    pub name: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletItemTagsRequest_TagName {
    fn default() -> &'a DeleteWalletItemTagsRequest_TagName {
        <DeleteWalletItemTagsRequest_TagName as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletItemTagsRequest_TagName {
    pub fn new() -> DeleteWalletItemTagsRequest_TagName {
        ::std::default::Default::default()
    }

    // .routeguide.DeleteWalletItemTagsRequest.TagType tagType = 1;


    pub fn get_tagType(&self) -> DeleteWalletItemTagsRequest_TagType {
        self.tagType
    }
    pub fn clear_tagType(&mut self) {
        self.tagType = DeleteWalletItemTagsRequest_TagType::ENCRYPTED;
    }

    // Param is passed by value, moved
    pub fn set_tagType(&mut self, v: DeleteWalletItemTagsRequest_TagType) {
        self.tagType = v;
    }

    // bytes name = 2;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeleteWalletItemTagsRequest_TagName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tagType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tagType != DeleteWalletItemTagsRequest_TagType::ENCRYPTED {
            my_size += ::protobuf::rt::enum_size(1, self.tagType);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tagType != DeleteWalletItemTagsRequest_TagType::ENCRYPTED {
            os.write_enum(1, self.tagType.value())?;
        }
        if !self.name.is_empty() {
            os.write_bytes(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletItemTagsRequest_TagName {
        DeleteWalletItemTagsRequest_TagName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeleteWalletItemTagsRequest_TagType>>(
                    "tagType",
                    |m: &DeleteWalletItemTagsRequest_TagName| { &m.tagType },
                    |m: &mut DeleteWalletItemTagsRequest_TagName| { &mut m.tagType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "name",
                    |m: &DeleteWalletItemTagsRequest_TagName| { &m.name },
                    |m: &mut DeleteWalletItemTagsRequest_TagName| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletItemTagsRequest_TagName>(
                    "DeleteWalletItemTagsRequest_TagName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletItemTagsRequest_TagName {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletItemTagsRequest_TagName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletItemTagsRequest_TagName,
        };
        unsafe {
            instance.get(DeleteWalletItemTagsRequest_TagName::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletItemTagsRequest_TagName {
    fn clear(&mut self) {
        self.tagType = DeleteWalletItemTagsRequest_TagType::ENCRYPTED;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletItemTagsRequest_TagName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletItemTagsRequest_TagName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeleteWalletItemTagsRequest_TagType {
    ENCRYPTED = 0,
    PLAINTEXT = 1,
}

impl ::protobuf::ProtobufEnum for DeleteWalletItemTagsRequest_TagType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeleteWalletItemTagsRequest_TagType> {
        match value {
            0 => ::std::option::Option::Some(DeleteWalletItemTagsRequest_TagType::ENCRYPTED),
            1 => ::std::option::Option::Some(DeleteWalletItemTagsRequest_TagType::PLAINTEXT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeleteWalletItemTagsRequest_TagType] = &[
            DeleteWalletItemTagsRequest_TagType::ENCRYPTED,
            DeleteWalletItemTagsRequest_TagType::PLAINTEXT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeleteWalletItemTagsRequest_TagType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeleteWalletItemTagsRequest_TagType {
}

impl ::std::default::Default for DeleteWalletItemTagsRequest_TagType {
    fn default() -> Self {
        DeleteWalletItemTagsRequest_TagType::ENCRYPTED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletItemTagsRequest_TagType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletItemTagsResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletItemTagsResponse {
    fn default() -> &'a DeleteWalletItemTagsResponse {
        <DeleteWalletItemTagsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletItemTagsResponse {
    pub fn new() -> DeleteWalletItemTagsResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWalletItemTagsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletItemTagsResponse {
        DeleteWalletItemTagsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &DeleteWalletItemTagsResponse| { &m.message },
                    |m: &mut DeleteWalletItemTagsResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletItemTagsResponse>(
                    "DeleteWalletItemTagsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletItemTagsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletItemTagsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletItemTagsResponse,
        };
        unsafe {
            instance.get(DeleteWalletItemTagsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletItemTagsResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletItemTagsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletItemTagsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletItemRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletItemRequest {
    fn default() -> &'a DeleteWalletItemRequest {
        <DeleteWalletItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletItemRequest {
    pub fn new() -> DeleteWalletItemRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // bytes id = 3;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeleteWalletItemRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.id.is_empty() {
            os.write_bytes(3, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletItemRequest {
        DeleteWalletItemRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &DeleteWalletItemRequest| { &m.walletId },
                    |m: &mut DeleteWalletItemRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &DeleteWalletItemRequest| { &m.field_type },
                    |m: &mut DeleteWalletItemRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "id",
                    |m: &DeleteWalletItemRequest| { &m.id },
                    |m: &mut DeleteWalletItemRequest| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletItemRequest>(
                    "DeleteWalletItemRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletItemRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletItemRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletItemRequest,
        };
        unsafe {
            instance.get(DeleteWalletItemRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletItemRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletItemRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWalletItemResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWalletItemResponse {
    fn default() -> &'a DeleteWalletItemResponse {
        <DeleteWalletItemResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWalletItemResponse {
    pub fn new() -> DeleteWalletItemResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWalletItemResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWalletItemResponse {
        DeleteWalletItemResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &DeleteWalletItemResponse| { &m.message },
                    |m: &mut DeleteWalletItemResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteWalletItemResponse>(
                    "DeleteWalletItemResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteWalletItemResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeleteWalletItemResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteWalletItemResponse,
        };
        unsafe {
            instance.get(DeleteWalletItemResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeleteWalletItemResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWalletItemResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWalletItemResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWalletMetadataRequest {
    // message fields
    pub walletId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWalletMetadataRequest {
    fn default() -> &'a GetWalletMetadataRequest {
        <GetWalletMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWalletMetadataRequest {
    pub fn new() -> GetWalletMetadataRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetWalletMetadataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWalletMetadataRequest {
        GetWalletMetadataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &GetWalletMetadataRequest| { &m.walletId },
                    |m: &mut GetWalletMetadataRequest| { &mut m.walletId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetWalletMetadataRequest>(
                    "GetWalletMetadataRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetWalletMetadataRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetWalletMetadataRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetWalletMetadataRequest,
        };
        unsafe {
            instance.get(GetWalletMetadataRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetWalletMetadataRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWalletMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWalletMetadataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetWalletMetadataResponse {
    // message fields
    pub metadata: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWalletMetadataResponse {
    fn default() -> &'a GetWalletMetadataResponse {
        <GetWalletMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetWalletMetadataResponse {
    pub fn new() -> GetWalletMetadataResponse {
        ::std::default::Default::default()
    }

    // bytes metadata = 1;


    pub fn get_metadata(&self) -> &[u8] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.metadata, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetWalletMetadataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.metadata.is_empty() {
            os.write_bytes(1, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWalletMetadataResponse {
        GetWalletMetadataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "metadata",
                    |m: &GetWalletMetadataResponse| { &m.metadata },
                    |m: &mut GetWalletMetadataResponse| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetWalletMetadataResponse>(
                    "GetWalletMetadataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetWalletMetadataResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetWalletMetadataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetWalletMetadataResponse,
        };
        unsafe {
            instance.get(GetWalletMetadataResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetWalletMetadataResponse {
    fn clear(&mut self) {
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetWalletMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWalletMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetWalletMetadataRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub metadata: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetWalletMetadataRequest {
    fn default() -> &'a SetWalletMetadataRequest {
        <SetWalletMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetWalletMetadataRequest {
    pub fn new() -> SetWalletMetadataRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes metadata = 2;


    pub fn get_metadata(&self) -> &[u8] {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.metadata, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SetWalletMetadataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.metadata.is_empty() {
            os.write_bytes(2, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetWalletMetadataRequest {
        SetWalletMetadataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &SetWalletMetadataRequest| { &m.walletId },
                    |m: &mut SetWalletMetadataRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "metadata",
                    |m: &SetWalletMetadataRequest| { &m.metadata },
                    |m: &mut SetWalletMetadataRequest| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetWalletMetadataRequest>(
                    "SetWalletMetadataRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetWalletMetadataRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetWalletMetadataRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetWalletMetadataRequest,
        };
        unsafe {
            instance.get(SetWalletMetadataRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetWalletMetadataRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetWalletMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetWalletMetadataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetWalletMetadataResponse {
    // message fields
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetWalletMetadataResponse {
    fn default() -> &'a SetWalletMetadataResponse {
        <SetWalletMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetWalletMetadataResponse {
    pub fn new() -> SetWalletMetadataResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetWalletMetadataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetWalletMetadataResponse {
        SetWalletMetadataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &SetWalletMetadataResponse| { &m.message },
                    |m: &mut SetWalletMetadataResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetWalletMetadataResponse>(
                    "SetWalletMetadataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetWalletMetadataResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetWalletMetadataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetWalletMetadataResponse,
        };
        unsafe {
            instance.get(SetWalletMetadataResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetWalletMetadataResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetWalletMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetWalletMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAllWalletItemsRequest {
    // message fields
    pub walletId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllWalletItemsRequest {
    fn default() -> &'a GetAllWalletItemsRequest {
        <GetAllWalletItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllWalletItemsRequest {
    pub fn new() -> GetAllWalletItemsRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAllWalletItemsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAllWalletItemsRequest {
        GetAllWalletItemsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &GetAllWalletItemsRequest| { &m.walletId },
                    |m: &mut GetAllWalletItemsRequest| { &mut m.walletId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAllWalletItemsRequest>(
                    "GetAllWalletItemsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAllWalletItemsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetAllWalletItemsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAllWalletItemsRequest,
        };
        unsafe {
            instance.get(GetAllWalletItemsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetAllWalletItemsRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllWalletItemsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllWalletItemsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAllWalletItemsResponse {
    // message fields
    pub walletItems: ::protobuf::RepeatedField<WalletItemResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllWalletItemsResponse {
    fn default() -> &'a GetAllWalletItemsResponse {
        <GetAllWalletItemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllWalletItemsResponse {
    pub fn new() -> GetAllWalletItemsResponse {
        ::std::default::Default::default()
    }

    // repeated .routeguide.WalletItemResponse walletItems = 1;


    pub fn get_walletItems(&self) -> &[WalletItemResponse] {
        &self.walletItems
    }
    pub fn clear_walletItems(&mut self) {
        self.walletItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletItems(&mut self, v: ::protobuf::RepeatedField<WalletItemResponse>) {
        self.walletItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_walletItems(&mut self) -> &mut ::protobuf::RepeatedField<WalletItemResponse> {
        &mut self.walletItems
    }

    // Take field
    pub fn take_walletItems(&mut self) -> ::protobuf::RepeatedField<WalletItemResponse> {
        ::std::mem::replace(&mut self.walletItems, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetAllWalletItemsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.walletItems {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.walletItems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.walletItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.walletItems {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAllWalletItemsResponse {
        GetAllWalletItemsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WalletItemResponse>>(
                    "walletItems",
                    |m: &GetAllWalletItemsResponse| { &m.walletItems },
                    |m: &mut GetAllWalletItemsResponse| { &mut m.walletItems },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAllWalletItemsResponse>(
                    "GetAllWalletItemsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAllWalletItemsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetAllWalletItemsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAllWalletItemsResponse,
        };
        unsafe {
            instance.get(GetAllWalletItemsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetAllWalletItemsResponse {
    fn clear(&mut self) {
        self.walletItems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllWalletItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllWalletItemsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchWalletItemsRequest {
    // message fields
    pub walletId: ::std::string::String,
    pub field_type: ::std::vec::Vec<u8>,
    pub query: ::std::string::String,
    pub options: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchWalletItemsRequest {
    fn default() -> &'a SearchWalletItemsRequest {
        <SearchWalletItemsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchWalletItemsRequest {
    pub fn new() -> SearchWalletItemsRequest {
        ::std::default::Default::default()
    }

    // string walletId = 1;


    pub fn get_walletId(&self) -> &str {
        &self.walletId
    }
    pub fn clear_walletId(&mut self) {
        self.walletId.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletId(&mut self, v: ::std::string::String) {
        self.walletId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_walletId(&mut self) -> &mut ::std::string::String {
        &mut self.walletId
    }

    // Take field
    pub fn take_walletId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.walletId, ::std::string::String::new())
    }

    // bytes type = 2;


    pub fn get_field_type(&self) -> &[u8] {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_type, ::std::vec::Vec::new())
    }

    // string query = 3;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string options = 4;


    pub fn get_options(&self) -> &str {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::string::String) {
        self.options = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut ::std::string::String {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.options, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchWalletItemsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.walletId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.walletId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.walletId);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.field_type);
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.query);
        }
        if !self.options.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.options);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.walletId.is_empty() {
            os.write_string(1, &self.walletId)?;
        }
        if !self.field_type.is_empty() {
            os.write_bytes(2, &self.field_type)?;
        }
        if !self.query.is_empty() {
            os.write_string(3, &self.query)?;
        }
        if !self.options.is_empty() {
            os.write_string(4, &self.options)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchWalletItemsRequest {
        SearchWalletItemsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "walletId",
                    |m: &SearchWalletItemsRequest| { &m.walletId },
                    |m: &mut SearchWalletItemsRequest| { &mut m.walletId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "type",
                    |m: &SearchWalletItemsRequest| { &m.field_type },
                    |m: &mut SearchWalletItemsRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SearchWalletItemsRequest| { &m.query },
                    |m: &mut SearchWalletItemsRequest| { &mut m.query },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    |m: &SearchWalletItemsRequest| { &m.options },
                    |m: &mut SearchWalletItemsRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchWalletItemsRequest>(
                    "SearchWalletItemsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchWalletItemsRequest {
        static mut instance: ::protobuf::lazy::Lazy<SearchWalletItemsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchWalletItemsRequest,
        };
        unsafe {
            instance.get(SearchWalletItemsRequest::new)
        }
    }
}

impl ::protobuf::Clear for SearchWalletItemsRequest {
    fn clear(&mut self) {
        self.walletId.clear();
        self.field_type.clear();
        self.query.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchWalletItemsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchWalletItemsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchWalletItemsResponse {
    // message fields
    pub walletItems: ::protobuf::RepeatedField<WalletItemResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchWalletItemsResponse {
    fn default() -> &'a SearchWalletItemsResponse {
        <SearchWalletItemsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchWalletItemsResponse {
    pub fn new() -> SearchWalletItemsResponse {
        ::std::default::Default::default()
    }

    // repeated .routeguide.WalletItemResponse walletItems = 1;


    pub fn get_walletItems(&self) -> &[WalletItemResponse] {
        &self.walletItems
    }
    pub fn clear_walletItems(&mut self) {
        self.walletItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_walletItems(&mut self, v: ::protobuf::RepeatedField<WalletItemResponse>) {
        self.walletItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_walletItems(&mut self) -> &mut ::protobuf::RepeatedField<WalletItemResponse> {
        &mut self.walletItems
    }

    // Take field
    pub fn take_walletItems(&mut self) -> ::protobuf::RepeatedField<WalletItemResponse> {
        ::std::mem::replace(&mut self.walletItems, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SearchWalletItemsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.walletItems {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.walletItems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.walletItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.walletItems {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchWalletItemsResponse {
        SearchWalletItemsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WalletItemResponse>>(
                    "walletItems",
                    |m: &SearchWalletItemsResponse| { &m.walletItems },
                    |m: &mut SearchWalletItemsResponse| { &mut m.walletItems },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchWalletItemsResponse>(
                    "SearchWalletItemsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchWalletItemsResponse {
        static mut instance: ::protobuf::lazy::Lazy<SearchWalletItemsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchWalletItemsResponse,
        };
        unsafe {
            instance.get(SearchWalletItemsResponse::new)
        }
    }
}

impl ::protobuf::Clear for SearchWalletItemsResponse {
    fn clear(&mut self) {
        self.walletItems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchWalletItemsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchWalletItemsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bsecure_wallet_service.proto\x12\nrouteguide\"R\n\x14EncryptedTagRe\
    sponse\x12\x12\n\x04name\x18\x01\x20\x01(\x0cR\x04name\x12&\n\x0eencrypt\
    edValue\x18\x02\x20\x01(\x0cR\x0eencryptedValue\"R\n\x14PlaintextTagResp\
    onse\x12\x12\n\x04name\x18\x01\x20\x01(\x0cR\x04name\x12&\n\x0eplaintext\
    Value\x18\x02\x20\x01(\tR\x0eplaintextValue\"\xf0\x01\n\x12WalletItemRes\
    ponse\x12\x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x0cR\x05value\x12\x10\n\x03key\x18\x03\x20\x01(\x0cR\x03ke\
    y\x12\x12\n\x04type\x18\x04\x20\x01(\x0cR\x04type\x12F\n\rencryptedTags\
    \x18\x05\x20\x03(\x0b2\x20.routeguide.EncryptedTagResponseR\rencryptedTa\
    gs\x12F\n\rplaintextTags\x18\x06\x20\x03(\x0b2\x20.routeguide.PlaintextT\
    agResponseR\rplaintextTags\"M\n\x13CreateWalletRequest\x12\x1a\n\x08wall\
    etId\x18\x01\x20\x01(\tR\x08walletId\x12\x1a\n\x08metadata\x18\x02\x20\
    \x01(\x0cR\x08metadata\"0\n\x14CreateWalletResponse\x12\x18\n\x07message\
    \x18\x01\x20\x01(\tR\x07message\"1\n\x13DeleteWalletRequest\x12\x1a\n\
    \x08walletId\x18\x01\x20\x01(\tR\x08walletId\"0\n\x14DeleteWalletRespons\
    e\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"1\n\x13WalletExis\
    tsRequest\x12\x1a\n\x08walletId\x18\x01\x20\x01(\tR\x08walletId\".\n\x14\
    WalletExistsResponse\x12\x16\n\x06exists\x18\x01\x20\x01(\x08R\x06exists\
    \"V\n\x14GetWalletItemRequest\x12\x1a\n\x08walletId\x18\x01\x20\x01(\tR\
    \x08walletId\x12\x12\n\x04type\x18\x02\x20\x01(\x0cR\x04type\x12\x0e\n\
    \x02id\x18\x03\x20\x01(\x0cR\x02id\"W\n\x15GetWalletItemResponse\x12>\n\
    \nwalletItem\x18\x01\x20\x01(\x0b2\x1e.routeguide.WalletItemResponseR\nw\
    alletItem\"\x8e\x02\n\x14AddWalletItemRequest\x12\x1a\n\x08walletId\x18\
    \x01\x20\x01(\tR\x08walletId\x12\x12\n\x04type\x18\x02\x20\x01(\x0cR\x04\
    type\x12\x0e\n\x02id\x18\x03\x20\x01(\x0cR\x02id\x12\x14\n\x05value\x18\
    \x04\x20\x01(\x0cR\x05value\x12\x10\n\x03key\x18\x05\x20\x01(\x0cR\x03ke\
    y\x12F\n\rencryptedTags\x18\x06\x20\x03(\x0b2\x20.routeguide.EncryptedTa\
    gResponseR\rencryptedTags\x12F\n\rplaintextTags\x18\x07\x20\x03(\x0b2\
    \x20.routeguide.PlaintextTagResponseR\rplaintextTags\"1\n\x15AddWalletIt\
    emResponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\x81\x01\
    \n\x17UpdateWalletItemRequest\x12\x1a\n\x08walletId\x18\x01\x20\x01(\tR\
    \x08walletId\x12\x12\n\x04type\x18\x02\x20\x01(\x0cR\x04type\x12\x0e\n\
    \x02id\x18\x03\x20\x01(\x0cR\x02id\x12\x14\n\x05value\x18\x04\x20\x01(\
    \x0cR\x05value\x12\x10\n\x03key\x18\x05\x20\x01(\x0cR\x03key\"4\n\x18Upd\
    ateWalletItemResponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07messag\
    e\"\xea\x01\n\x18AddWalletItemTagsRequest\x12\x1a\n\x08walletId\x18\x01\
    \x20\x01(\tR\x08walletId\x12\x12\n\x04type\x18\x02\x20\x01(\x0cR\x04type\
    \x12\x0e\n\x02id\x18\x03\x20\x01(\x0cR\x02id\x12F\n\rencryptedTags\x18\
    \x04\x20\x03(\x0b2\x20.routeguide.EncryptedTagResponseR\rencryptedTags\
    \x12F\n\rplaintextTags\x18\x05\x20\x03(\x0b2\x20.routeguide.PlaintextTag\
    ResponseR\rplaintextTags\"5\n\x19AddWalletItemTagsResponse\x12\x18\n\x07\
    message\x18\x01\x20\x01(\tR\x07message\"\xed\x01\n\x1bUpdateWalletItemTa\
    gsRequest\x12\x1a\n\x08walletId\x18\x01\x20\x01(\tR\x08walletId\x12\x12\
    \n\x04type\x18\x02\x20\x01(\x0cR\x04type\x12\x0e\n\x02id\x18\x03\x20\x01\
    (\x0cR\x02id\x12F\n\rencryptedTags\x18\x04\x20\x03(\x0b2\x20.routeguide.\
    EncryptedTagResponseR\rencryptedTags\x12F\n\rplaintextTags\x18\x05\x20\
    \x03(\x0b2\x20.routeguide.PlaintextTagResponseR\rplaintextTags\"8\n\x1cU\
    pdateWalletItemTagsResponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07\
    message\"\xbd\x02\n\x1bDeleteWalletItemTagsRequest\x12\x1a\n\x08walletId\
    \x18\x01\x20\x01(\tR\x08walletId\x12\x12\n\x04type\x18\x02\x20\x01(\x0cR\
    \x04type\x12\x0e\n\x02id\x18\x03\x20\x01(\x0cR\x02id\x12K\n\x08tagNames\
    \x18\x04\x20\x03(\x0b2/.routeguide.DeleteWalletItemTagsRequest.TagNameR\
    \x08tagNames\x1ah\n\x07TagName\x12I\n\x07tagType\x18\x01\x20\x01(\x0e2/.\
    routeguide.DeleteWalletItemTagsRequest.TagTypeR\x07tagType\x12\x12\n\x04\
    name\x18\x02\x20\x01(\x0cR\x04name\"'\n\x07TagType\x12\r\n\tENCRYPTED\
    \x10\0\x12\r\n\tPLAINTEXT\x10\x01\"8\n\x1cDeleteWalletItemTagsResponse\
    \x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"Y\n\x17DeleteWalle\
    tItemRequest\x12\x1a\n\x08walletId\x18\x01\x20\x01(\tR\x08walletId\x12\
    \x12\n\x04type\x18\x02\x20\x01(\x0cR\x04type\x12\x0e\n\x02id\x18\x03\x20\
    \x01(\x0cR\x02id\"4\n\x18DeleteWalletItemResponse\x12\x18\n\x07message\
    \x18\x01\x20\x01(\tR\x07message\"6\n\x18GetWalletMetadataRequest\x12\x1a\
    \n\x08walletId\x18\x01\x20\x01(\tR\x08walletId\"7\n\x19GetWalletMetadata\
    Response\x12\x1a\n\x08metadata\x18\x01\x20\x01(\x0cR\x08metadata\"R\n\
    \x18SetWalletMetadataRequest\x12\x1a\n\x08walletId\x18\x01\x20\x01(\tR\
    \x08walletId\x12\x1a\n\x08metadata\x18\x02\x20\x01(\x0cR\x08metadata\"5\
    \n\x19SetWalletMetadataResponse\x12\x18\n\x07message\x18\x01\x20\x01(\tR\
    \x07message\"6\n\x18GetAllWalletItemsRequest\x12\x1a\n\x08walletId\x18\
    \x01\x20\x01(\tR\x08walletId\"]\n\x19GetAllWalletItemsResponse\x12@\n\
    \x0bwalletItems\x18\x01\x20\x03(\x0b2\x1e.routeguide.WalletItemResponseR\
    \x0bwalletItems\"z\n\x18SearchWalletItemsRequest\x12\x1a\n\x08walletId\
    \x18\x01\x20\x01(\tR\x08walletId\x12\x12\n\x04type\x18\x02\x20\x01(\x0cR\
    \x04type\x12\x14\n\x05query\x18\x03\x20\x01(\tR\x05query\x12\x18\n\x07op\
    tions\x18\x04\x20\x01(\tR\x07options\"]\n\x19SearchWalletItemsResponse\
    \x12@\n\x0bwalletItems\x18\x01\x20\x03(\x0b2\x1e.routeguide.WalletItemRe\
    sponseR\x0bwalletItems2\xcd\n\n\x0cSecureWallet\x12S\n\x0cCreateWallet\
    \x12\x1f.routeguide.CreateWalletRequest\x1a\x20.routeguide.CreateWalletR\
    esponse\"\0\x12S\n\x0cDeleteWallet\x12\x1f.routeguide.DeleteWalletReques\
    t\x1a\x20.routeguide.DeleteWalletResponse\"\0\x12S\n\x0cWalletExists\x12\
    \x1f.routeguide.WalletExistsRequest\x1a\x20.routeguide.WalletExistsRespo\
    nse\"\0\x12b\n\x11GetWalletMetadata\x12$.routeguide.GetWalletMetadataReq\
    uest\x1a%.routeguide.GetWalletMetadataResponse\"\0\x12b\n\x11SetWalletMe\
    tadata\x12$.routeguide.SetWalletMetadataRequest\x1a%.routeguide.SetWalle\
    tMetadataResponse\"\0\x12V\n\rAddWalletItem\x12\x20.routeguide.AddWallet\
    ItemRequest\x1a!.routeguide.AddWalletItemResponse\"\0\x12V\n\rGetWalletI\
    tem\x12\x20.routeguide.GetWalletItemRequest\x1a!.routeguide.GetWalletIte\
    mResponse\"\0\x12b\n\x11GetAllWalletItems\x12$.routeguide.GetAllWalletIt\
    emsRequest\x1a%.routeguide.GetAllWalletItemsResponse\"\0\x12b\n\x11Searc\
    hWalletItems\x12$.routeguide.SearchWalletItemsRequest\x1a%.routeguide.Se\
    archWalletItemsResponse\"\0\x12_\n\x10UpdateWalletItem\x12#.routeguide.U\
    pdateWalletItemRequest\x1a$.routeguide.UpdateWalletItemResponse\"\0\x12_\
    \n\x10DeleteWalletItem\x12#.routeguide.DeleteWalletItemRequest\x1a$.rout\
    eguide.DeleteWalletItemResponse\"\0\x12b\n\x11AddWalletItemTags\x12$.rou\
    teguide.AddWalletItemTagsRequest\x1a%.routeguide.AddWalletItemTagsRespon\
    se\"\0\x12k\n\x14UpdateWalletItemTags\x12'.routeguide.UpdateWalletItemTa\
    gsRequest\x1a(.routeguide.UpdateWalletItemTagsResponse\"\0\x12k\n\x14Del\
    eteWalletItemTags\x12'.routeguide.DeleteWalletItemTagsRequest\x1a(.route\
    guide.DeleteWalletItemTagsResponse\"\0BG\n$com.tbcasoft.ccis.securewalle\
    t.protoB\x17SecureWalletServerProtoP\x01\xa2\x02\x03SWSJ\xdc3\n\x07\x12\
    \x05\x0e\0\xd2\x01\x01\n\xc4\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb9\x04\n\
    \x20TBCASOFT,\x20INC.\x20PROPRIETARY\x20AND\x20CONFIDENTIAL\x20INFORMATI\
    ON\n\n\x20Copyright\x20(C)\x20TBCASOFT,\x20INC.\x20-\x20All\x20Rights\
    \x20Reserved.\n\n\x20NOTICE:\x20All\x20information\x20contained\x20herei\
    n\x20is,\x20and\x20remains\x20the\x20property\x20of\n\x20TBCASOFT,\x20IN\
    C.\x20The\x20intellectual\x20and\x20technical\x20concepts/expressions\
    \x20contained\n\x20herein\x20are\x20proprietary\x20to\x20TBCASOFT,\x20IN\
    C.\x20and\x20may\x20be\x20covered\x20by\x20U.S.\x20and\n\x20Foreign\x20P\
    atents,\x20and\x20are\x20protected\x20by\x20trade\x20secret\x20and/or\
    \x20copyright\x20law.\n\x20Dissemination\x20of\x20this\x20information\
    \x20or\x20reproduction\x20of\x20this\x20material\x20is\n\x20strictly\x20\
    forbidden\x20unless\x20prior\x20written\x20permission\x20is\x20obtained\
    \x20from\n\x20TBCASOFT,\x20INC.\n\n\n\x08\n\x01\x08\x12\x03\x10\0\"\n\t\
    \n\x02\x08\n\x12\x03\x10\0\"\n\x08\n\x01\x08\x12\x03\x11\0=\n\t\n\x02\
    \x08\x01\x12\x03\x11\0=\n\x08\n\x01\x08\x12\x03\x12\08\n\t\n\x02\x08\x08\
    \x12\x03\x12\08\n\x08\n\x01\x08\x12\x03\x13\0!\n\t\n\x02\x08$\x12\x03\
    \x13\0!\n\x08\n\x01\x02\x12\x03\x15\0\x13\n\n\n\x02\x06\0\x12\x04\x17\0&\
    \x01\n\n\n\x03\x06\0\x01\x12\x03\x17\x08\x14\n\x0b\n\x04\x06\0\x02\0\x12\
    \x03\x18\x04K\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x18\x08\x14\n\x0c\n\
    \x05\x06\0\x02\0\x02\x12\x03\x18\x15(\n\x0c\n\x05\x06\0\x02\0\x03\x12\
    \x03\x183G\n\x0b\n\x04\x06\0\x02\x01\x12\x03\x19\x04K\n\x0c\n\x05\x06\0\
    \x02\x01\x01\x12\x03\x19\x08\x14\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\
    \x19\x15(\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x193G\n\x0b\n\x04\x06\0\
    \x02\x02\x12\x03\x1a\x04K\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x1a\x08\
    \x14\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\x1a\x15(\n\x0c\n\x05\x06\0\
    \x02\x02\x03\x12\x03\x1a3G\n\x0b\n\x04\x06\0\x02\x03\x12\x03\x1b\x04Z\n\
    \x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x1b\x08\x19\n\x0c\n\x05\x06\0\x02\
    \x03\x02\x12\x03\x1b\x1a2\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x1b=V\n\
    \x0b\n\x04\x06\0\x02\x04\x12\x03\x1c\x04Z\n\x0c\n\x05\x06\0\x02\x04\x01\
    \x12\x03\x1c\x08\x19\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\x1c\x1a2\n\
    \x0c\n\x05\x06\0\x02\x04\x03\x12\x03\x1c=V\n\x0b\n\x04\x06\0\x02\x05\x12\
    \x03\x1d\x04N\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03\x1d\x08\x15\n\x0c\n\
    \x05\x06\0\x02\x05\x02\x12\x03\x1d\x16*\n\x0c\n\x05\x06\0\x02\x05\x03\
    \x12\x03\x1d5J\n\x0b\n\x04\x06\0\x02\x06\x12\x03\x1e\x04N\n\x0c\n\x05\
    \x06\0\x02\x06\x01\x12\x03\x1e\x08\x15\n\x0c\n\x05\x06\0\x02\x06\x02\x12\
    \x03\x1e\x16*\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03\x1e5J\n\x0b\n\x04\
    \x06\0\x02\x07\x12\x03\x1f\x04Z\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\
    \x1f\x08\x19\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\x1f\x1a2\n\x0c\n\x05\
    \x06\0\x02\x07\x03\x12\x03\x1f=V\n\x0b\n\x04\x06\0\x02\x08\x12\x03\x20\
    \x04Z\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03\x20\x08\x19\n\x0c\n\x05\x06\
    \0\x02\x08\x02\x12\x03\x20\x1a2\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03\
    \x20=V\n\x0b\n\x04\x06\0\x02\t\x12\x03!\x04W\n\x0c\n\x05\x06\0\x02\t\x01\
    \x12\x03!\x08\x18\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03!\x190\n\x0c\n\x05\
    \x06\0\x02\t\x03\x12\x03!;S\n\x0b\n\x04\x06\0\x02\n\x12\x03\"\x04W\n\x0c\
    \n\x05\x06\0\x02\n\x01\x12\x03\"\x08\x18\n\x0c\n\x05\x06\0\x02\n\x02\x12\
    \x03\"\x190\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03\";S\n\x0b\n\x04\x06\0\
    \x02\x0b\x12\x03#\x04Z\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03#\x08\x19\n\
    \x0c\n\x05\x06\0\x02\x0b\x02\x12\x03#\x1a2\n\x0c\n\x05\x06\0\x02\x0b\x03\
    \x12\x03#=V\n\x0b\n\x04\x06\0\x02\x0c\x12\x03$\x04c\n\x0c\n\x05\x06\0\
    \x02\x0c\x01\x12\x03$\x08\x1c\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03$\x1d\
    8\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03$C_\n\x0b\n\x04\x06\0\x02\r\x12\
    \x03%\x04c\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03%\x08\x1c\n\x0c\n\x05\x06\
    \0\x02\r\x02\x12\x03%\x1d8\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03%C_\n\n\n\
    \x02\x04\0\x12\x04(\0+\x01\n\n\n\x03\x04\0\x01\x12\x03(\x08\x1c\n\x0b\n\
    \x04\x04\0\x02\0\x12\x03)\x04\x13\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03)\
    \x04\t\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03)\n\x0e\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x03)\x11\x12\n\x0b\n\x04\x04\0\x02\x01\x12\x03*\x04\x1d\n\x0c\
    \n\x05\x04\0\x02\x01\x05\x12\x03*\x04\t\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03*\n\x18\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03*\x1b\x1c\n\n\n\x02\
    \x04\x01\x12\x04-\00\x01\n\n\n\x03\x04\x01\x01\x12\x03-\x08\x1c\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03.\x04\x13\n\x0c\n\x05\x04\x01\x02\0\x05\x12\
    \x03.\x04\t\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03.\n\x0e\n\x0c\n\x05\x04\
    \x01\x02\0\x03\x12\x03.\x11\x12\n\x0b\n\x04\x04\x01\x02\x01\x12\x03/\x04\
    \x1e\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03/\x04\n\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03/\x0b\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03/\
    \x1c\x1d\n\n\n\x02\x04\x02\x12\x042\09\x01\n\n\n\x03\x04\x02\x01\x12\x03\
    2\x08\x1a\n\x0b\n\x04\x04\x02\x02\0\x12\x033\x04\x11\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x033\x04\t\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x033\n\x0c\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x033\x0f\x10\n\x0b\n\x04\x04\x02\x02\
    \x01\x12\x034\x04\x14\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x034\x04\t\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x034\n\x0f\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x034\x12\x13\n\x0b\n\x04\x04\x02\x02\x02\x12\x035\x04\x12\n\
    \x0c\n\x05\x04\x02\x02\x02\x05\x12\x035\x04\t\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x035\n\r\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x035\x10\x11\n\
    \x0b\n\x04\x04\x02\x02\x03\x12\x036\x04\x13\n\x0c\n\x05\x04\x02\x02\x03\
    \x05\x12\x036\x04\t\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x036\n\x0e\n\x0c\
    \n\x05\x04\x02\x02\x03\x03\x12\x036\x11\x12\n\x0b\n\x04\x04\x02\x02\x04\
    \x12\x037\x044\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x037\x04\x0c\n\x0c\n\
    \x05\x04\x02\x02\x04\x06\x12\x037\r!\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\
    \x037\"/\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03723\n\x0b\n\x04\x04\x02\
    \x02\x05\x12\x038\x044\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x038\x04\x0c\
    \n\x0c\n\x05\x04\x02\x02\x05\x06\x12\x038\r!\n\x0c\n\x05\x04\x02\x02\x05\
    \x01\x12\x038\"/\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03823\n\n\n\x02\
    \x04\x03\x12\x04;\0>\x01\n\n\n\x03\x04\x03\x01\x12\x03;\x08\x1b\n\x0b\n\
    \x04\x04\x03\x02\0\x12\x03<\x04\x18\n\x0c\n\x05\x04\x03\x02\0\x05\x12\
    \x03<\x04\n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03<\x0b\x13\n\x0c\n\x05\
    \x04\x03\x02\0\x03\x12\x03<\x16\x17\n\x0b\n\x04\x04\x03\x02\x01\x12\x03=\
    \x04\x17\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03=\x04\t\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03=\n\x12\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03=\
    \x15\x16\n\n\n\x02\x04\x04\x12\x04@\0B\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    @\x08\x1c\n\x0b\n\x04\x04\x04\x02\0\x12\x03A\x04\x17\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03A\x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03A\x0b\x12\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03A\x15\x16\n\n\n\x02\x04\x05\x12\
    \x04D\0F\x01\n\n\n\x03\x04\x05\x01\x12\x03D\x08\x1b\n\x0b\n\x04\x04\x05\
    \x02\0\x12\x03E\x04\x18\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03E\x04\n\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03E\x0b\x13\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03E\x16\x17\n\n\n\x02\x04\x06\x12\x04H\0J\x01\n\n\n\x03\x04\
    \x06\x01\x12\x03H\x08\x1c\n\x0b\n\x04\x04\x06\x02\0\x12\x03I\x04\x17\n\
    \x0c\n\x05\x04\x06\x02\0\x05\x12\x03I\x04\n\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03I\x0b\x12\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03I\x15\x16\n\n\
    \n\x02\x04\x07\x12\x04L\0N\x01\n\n\n\x03\x04\x07\x01\x12\x03L\x08\x1b\n\
    \x0b\n\x04\x04\x07\x02\0\x12\x03M\x04\x18\n\x0c\n\x05\x04\x07\x02\0\x05\
    \x12\x03M\x04\n\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03M\x0b\x13\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x03M\x16\x17\n\n\n\x02\x04\x08\x12\x04P\0R\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03P\x08\x1c\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03Q\x04\x14\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03Q\x04\x08\n\x0c\n\
    \x05\x04\x08\x02\0\x01\x12\x03Q\t\x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\
    \x03Q\x12\x13\n\n\n\x02\x04\t\x12\x04T\0X\x01\n\n\n\x03\x04\t\x01\x12\
    \x03T\x08\x1c\n\x0b\n\x04\x04\t\x02\0\x12\x03U\x04\x18\n\x0c\n\x05\x04\t\
    \x02\0\x05\x12\x03U\x04\n\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03U\x0b\x13\n\
    \x0c\n\x05\x04\t\x02\0\x03\x12\x03U\x16\x17\n\x0b\n\x04\x04\t\x02\x01\
    \x12\x03V\x04\x13\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03V\x04\t\n\x0c\n\
    \x05\x04\t\x02\x01\x01\x12\x03V\n\x0e\n\x0c\n\x05\x04\t\x02\x01\x03\x12\
    \x03V\x11\x12\n\x0b\n\x04\x04\t\x02\x02\x12\x03W\x04\x11\n\x0c\n\x05\x04\
    \t\x02\x02\x05\x12\x03W\x04\t\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03W\n\
    \x0c\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03W\x0f\x10\n\n\n\x02\x04\n\x12\
    \x04Z\0\\\x01\n\n\n\x03\x04\n\x01\x12\x03Z\x08\x1d\n\x0b\n\x04\x04\n\x02\
    \0\x12\x03[\x04&\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03[\x04\x16\n\x0c\n\
    \x05\x04\n\x02\0\x01\x12\x03[\x17!\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03[$\
    %\n\n\n\x02\x04\x0b\x12\x04^\0f\x01\n\n\n\x03\x04\x0b\x01\x12\x03^\x08\
    \x1c\n\x0b\n\x04\x04\x0b\x02\0\x12\x03_\x04\x18\n\x0c\n\x05\x04\x0b\x02\
    \0\x05\x12\x03_\x04\n\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03_\x0b\x13\n\
    \x0c\n\x05\x04\x0b\x02\0\x03\x12\x03_\x16\x17\n\x0b\n\x04\x04\x0b\x02\
    \x01\x12\x03`\x04\x13\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03`\x04\t\n\
    \x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03`\n\x0e\n\x0c\n\x05\x04\x0b\x02\
    \x01\x03\x12\x03`\x11\x12\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03a\x04\x11\n\
    \x0c\n\x05\x04\x0b\x02\x02\x05\x12\x03a\x04\t\n\x0c\n\x05\x04\x0b\x02\
    \x02\x01\x12\x03a\n\x0c\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03a\x0f\x10\
    \n\x0b\n\x04\x04\x0b\x02\x03\x12\x03b\x04\x14\n\x0c\n\x05\x04\x0b\x02\
    \x03\x05\x12\x03b\x04\t\n\x0c\n\x05\x04\x0b\x02\x03\x01\x12\x03b\n\x0f\n\
    \x0c\n\x05\x04\x0b\x02\x03\x03\x12\x03b\x12\x13\n\x0b\n\x04\x04\x0b\x02\
    \x04\x12\x03c\x04\x12\n\x0c\n\x05\x04\x0b\x02\x04\x05\x12\x03c\x04\t\n\
    \x0c\n\x05\x04\x0b\x02\x04\x01\x12\x03c\n\r\n\x0c\n\x05\x04\x0b\x02\x04\
    \x03\x12\x03c\x10\x11\n\x0b\n\x04\x04\x0b\x02\x05\x12\x03d\x044\n\x0c\n\
    \x05\x04\x0b\x02\x05\x04\x12\x03d\x04\x0c\n\x0c\n\x05\x04\x0b\x02\x05\
    \x06\x12\x03d\r!\n\x0c\n\x05\x04\x0b\x02\x05\x01\x12\x03d\"/\n\x0c\n\x05\
    \x04\x0b\x02\x05\x03\x12\x03d23\n\x0b\n\x04\x04\x0b\x02\x06\x12\x03e\x04\
    4\n\x0c\n\x05\x04\x0b\x02\x06\x04\x12\x03e\x04\x0c\n\x0c\n\x05\x04\x0b\
    \x02\x06\x06\x12\x03e\r!\n\x0c\n\x05\x04\x0b\x02\x06\x01\x12\x03e\"/\n\
    \x0c\n\x05\x04\x0b\x02\x06\x03\x12\x03e23\n\n\n\x02\x04\x0c\x12\x04h\0j\
    \x01\n\n\n\x03\x04\x0c\x01\x12\x03h\x08\x1d\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03i\x04\x17\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03i\x04\n\n\x0c\n\
    \x05\x04\x0c\x02\0\x01\x12\x03i\x0b\x12\n\x0c\n\x05\x04\x0c\x02\0\x03\
    \x12\x03i\x15\x16\n\n\n\x02\x04\r\x12\x04l\0r\x01\n\n\n\x03\x04\r\x01\
    \x12\x03l\x08\x1f\n\x0b\n\x04\x04\r\x02\0\x12\x03m\x04\x18\n\x0c\n\x05\
    \x04\r\x02\0\x05\x12\x03m\x04\n\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03m\x0b\
    \x13\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03m\x16\x17\n\x0b\n\x04\x04\r\x02\
    \x01\x12\x03n\x04\x13\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03n\x04\t\n\x0c\
    \n\x05\x04\r\x02\x01\x01\x12\x03n\n\x0e\n\x0c\n\x05\x04\r\x02\x01\x03\
    \x12\x03n\x11\x12\n\x0b\n\x04\x04\r\x02\x02\x12\x03o\x04\x11\n\x0c\n\x05\
    \x04\r\x02\x02\x05\x12\x03o\x04\t\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03o\
    \n\x0c\n\x0c\n\x05\x04\r\x02\x02\x03\x12\x03o\x0f\x10\n\x0b\n\x04\x04\r\
    \x02\x03\x12\x03p\x04\x14\n\x0c\n\x05\x04\r\x02\x03\x05\x12\x03p\x04\t\n\
    \x0c\n\x05\x04\r\x02\x03\x01\x12\x03p\n\x0f\n\x0c\n\x05\x04\r\x02\x03\
    \x03\x12\x03p\x12\x13\n\x0b\n\x04\x04\r\x02\x04\x12\x03q\x04\x12\n\x0c\n\
    \x05\x04\r\x02\x04\x05\x12\x03q\x04\t\n\x0c\n\x05\x04\r\x02\x04\x01\x12\
    \x03q\n\r\n\x0c\n\x05\x04\r\x02\x04\x03\x12\x03q\x10\x11\n\n\n\x02\x04\
    \x0e\x12\x04t\0v\x01\n\n\n\x03\x04\x0e\x01\x12\x03t\x08\x20\n\x0b\n\x04\
    \x04\x0e\x02\0\x12\x03u\x04\x17\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03u\
    \x04\n\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03u\x0b\x12\n\x0c\n\x05\x04\
    \x0e\x02\0\x03\x12\x03u\x15\x16\n\n\n\x02\x04\x0f\x12\x04x\0~\x01\n\n\n\
    \x03\x04\x0f\x01\x12\x03x\x08\x20\n\x0b\n\x04\x04\x0f\x02\0\x12\x03y\x04\
    \x18\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03y\x04\n\n\x0c\n\x05\x04\x0f\
    \x02\0\x01\x12\x03y\x0b\x13\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03y\x16\
    \x17\n\x0b\n\x04\x04\x0f\x02\x01\x12\x03z\x04\x13\n\x0c\n\x05\x04\x0f\
    \x02\x01\x05\x12\x03z\x04\t\n\x0c\n\x05\x04\x0f\x02\x01\x01\x12\x03z\n\
    \x0e\n\x0c\n\x05\x04\x0f\x02\x01\x03\x12\x03z\x11\x12\n\x0b\n\x04\x04\
    \x0f\x02\x02\x12\x03{\x04\x11\n\x0c\n\x05\x04\x0f\x02\x02\x05\x12\x03{\
    \x04\t\n\x0c\n\x05\x04\x0f\x02\x02\x01\x12\x03{\n\x0c\n\x0c\n\x05\x04\
    \x0f\x02\x02\x03\x12\x03{\x0f\x10\n\x0b\n\x04\x04\x0f\x02\x03\x12\x03|\
    \x044\n\x0c\n\x05\x04\x0f\x02\x03\x04\x12\x03|\x04\x0c\n\x0c\n\x05\x04\
    \x0f\x02\x03\x06\x12\x03|\r!\n\x0c\n\x05\x04\x0f\x02\x03\x01\x12\x03|\"/\
    \n\x0c\n\x05\x04\x0f\x02\x03\x03\x12\x03|23\n\x0b\n\x04\x04\x0f\x02\x04\
    \x12\x03}\x044\n\x0c\n\x05\x04\x0f\x02\x04\x04\x12\x03}\x04\x0c\n\x0c\n\
    \x05\x04\x0f\x02\x04\x06\x12\x03}\r!\n\x0c\n\x05\x04\x0f\x02\x04\x01\x12\
    \x03}\"/\n\x0c\n\x05\x04\x0f\x02\x04\x03\x12\x03}23\n\x0c\n\x02\x04\x10\
    \x12\x06\x80\x01\0\x82\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x80\x01\
    \x08!\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x81\x01\x04\x17\n\r\n\x05\x04\
    \x10\x02\0\x05\x12\x04\x81\x01\x04\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \x81\x01\x0b\x12\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x81\x01\x15\x16\n\
    \x0c\n\x02\x04\x11\x12\x06\x84\x01\0\x8a\x01\x01\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\x84\x01\x08#\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x85\x01\x04\x18\
    \n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x85\x01\x04\n\n\r\n\x05\x04\x11\x02\
    \0\x01\x12\x04\x85\x01\x0b\x13\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x85\
    \x01\x16\x17\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x86\x01\x04\x13\n\r\n\
    \x05\x04\x11\x02\x01\x05\x12\x04\x86\x01\x04\t\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\x86\x01\n\x0e\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x86\x01\
    \x11\x12\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\x87\x01\x04\x11\n\r\n\x05\
    \x04\x11\x02\x02\x05\x12\x04\x87\x01\x04\t\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\x87\x01\n\x0c\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\x87\x01\x0f\
    \x10\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\x88\x01\x044\n\r\n\x05\x04\x11\
    \x02\x03\x04\x12\x04\x88\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x03\x06\x12\
    \x04\x88\x01\r!\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x88\x01\"/\n\r\n\
    \x05\x04\x11\x02\x03\x03\x12\x04\x88\x0123\n\x0c\n\x04\x04\x11\x02\x04\
    \x12\x04\x89\x01\x044\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\x89\x01\x04\
    \x0c\n\r\n\x05\x04\x11\x02\x04\x06\x12\x04\x89\x01\r!\n\r\n\x05\x04\x11\
    \x02\x04\x01\x12\x04\x89\x01\"/\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\
    \x89\x0123\n\x0c\n\x02\x04\x12\x12\x06\x8c\x01\0\x8e\x01\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\x8c\x01\x08$\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x8d\
    \x01\x04\x17\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x8d\x01\x04\n\n\r\n\x05\
    \x04\x12\x02\0\x01\x12\x04\x8d\x01\x0b\x12\n\r\n\x05\x04\x12\x02\0\x03\
    \x12\x04\x8d\x01\x15\x16\n\x0c\n\x02\x04\x13\x12\x06\x90\x01\0\xa0\x01\
    \x01\n\x0b\n\x03\x04\x13\x01\x12\x04\x90\x01\x08#\n\x0c\n\x04\x04\x13\
    \x02\0\x12\x04\x91\x01\x04\x18\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x91\
    \x01\x04\n\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x91\x01\x0b\x13\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\x91\x01\x16\x17\n\x0c\n\x04\x04\x13\x02\x01\
    \x12\x04\x92\x01\x04\x13\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\x92\x01\
    \x04\t\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x92\x01\n\x0e\n\r\n\x05\x04\
    \x13\x02\x01\x03\x12\x04\x92\x01\x11\x12\n\x0c\n\x04\x04\x13\x02\x02\x12\
    \x04\x93\x01\x04\x11\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\x93\x01\x04\t\
    \n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\x93\x01\n\x0c\n\r\n\x05\x04\x13\
    \x02\x02\x03\x12\x04\x93\x01\x0f\x10\n\x0e\n\x04\x04\x13\x04\0\x12\x06\
    \x95\x01\x04\x98\x01\x05\n\r\n\x05\x04\x13\x04\0\x01\x12\x04\x95\x01\t\
    \x10\n\x0e\n\x06\x04\x13\x04\0\x02\0\x12\x04\x96\x01\x08\x16\n\x0f\n\x07\
    \x04\x13\x04\0\x02\0\x01\x12\x04\x96\x01\x08\x11\n\x0f\n\x07\x04\x13\x04\
    \0\x02\0\x02\x12\x04\x96\x01\x14\x15\n\x0e\n\x06\x04\x13\x04\0\x02\x01\
    \x12\x04\x97\x01\x08\x16\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x01\x12\x04\
    \x97\x01\x08\x11\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x02\x12\x04\x97\x01\
    \x14\x15\n\x0e\n\x04\x04\x13\x03\0\x12\x06\x9a\x01\x04\x9d\x01\x05\n\r\n\
    \x05\x04\x13\x03\0\x01\x12\x04\x9a\x01\x0c\x13\n\x0e\n\x06\x04\x13\x03\0\
    \x02\0\x12\x04\x9b\x01\x08\x1c\n\x0f\n\x07\x04\x13\x03\0\x02\0\x06\x12\
    \x04\x9b\x01\x08\x0f\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\x12\x04\x9b\x01\
    \x10\x17\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\x9b\x01\x1a\x1b\n\
    \x0e\n\x06\x04\x13\x03\0\x02\x01\x12\x04\x9c\x01\x08\x17\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x01\x05\x12\x04\x9c\x01\x08\r\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x01\x01\x12\x04\x9c\x01\x0e\x12\n\x0f\n\x07\x04\x13\x03\0\x02\x01\
    \x03\x12\x04\x9c\x01\x15\x16\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\x9f\x01\
    \x04\"\n\r\n\x05\x04\x13\x02\x03\x04\x12\x04\x9f\x01\x04\x0c\n\r\n\x05\
    \x04\x13\x02\x03\x06\x12\x04\x9f\x01\r\x14\n\r\n\x05\x04\x13\x02\x03\x01\
    \x12\x04\x9f\x01\x15\x1d\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x9f\x01\
    \x20!\n\x0c\n\x02\x04\x14\x12\x06\xa2\x01\0\xa4\x01\x01\n\x0b\n\x03\x04\
    \x14\x01\x12\x04\xa2\x01\x08$\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xa3\x01\
    \x04\x17\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xa3\x01\x04\n\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\xa3\x01\x0b\x12\n\r\n\x05\x04\x14\x02\0\x03\x12\
    \x04\xa3\x01\x15\x16\n\x0c\n\x02\x04\x15\x12\x06\xa6\x01\0\xaa\x01\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xa6\x01\x08\x1f\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\xa7\x01\x04\x18\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xa7\x01\x04\
    \n\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xa7\x01\x0b\x13\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\xa7\x01\x16\x17\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\
    \xa8\x01\x04\x13\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xa8\x01\x04\t\n\r\
    \n\x05\x04\x15\x02\x01\x01\x12\x04\xa8\x01\n\x0e\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\xa8\x01\x11\x12\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xa9\
    \x01\x04\x11\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xa9\x01\x04\t\n\r\n\
    \x05\x04\x15\x02\x02\x01\x12\x04\xa9\x01\n\x0c\n\r\n\x05\x04\x15\x02\x02\
    \x03\x12\x04\xa9\x01\x0f\x10\n\x0c\n\x02\x04\x16\x12\x06\xac\x01\0\xae\
    \x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xac\x01\x08\x20\n\x0c\n\x04\x04\
    \x16\x02\0\x12\x04\xad\x01\x04\x17\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\
    \xad\x01\x04\n\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xad\x01\x0b\x12\n\r\n\
    \x05\x04\x16\x02\0\x03\x12\x04\xad\x01\x15\x16\n\x0c\n\x02\x04\x17\x12\
    \x06\xb0\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xb0\x01\x08\
    \x20\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xb1\x01\x04\x18\n\r\n\x05\x04\x17\
    \x02\0\x05\x12\x04\xb1\x01\x04\n\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xb1\
    \x01\x0b\x13\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xb1\x01\x16\x17\n\x0c\n\
    \x02\x04\x18\x12\x06\xb4\x01\0\xb6\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xb4\x01\x08!\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xb5\x01\x04\x17\n\r\
    \n\x05\x04\x18\x02\0\x05\x12\x04\xb5\x01\x04\t\n\r\n\x05\x04\x18\x02\0\
    \x01\x12\x04\xb5\x01\n\x12\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xb5\x01\
    \x15\x16\n\x0c\n\x02\x04\x19\x12\x06\xb8\x01\0\xbb\x01\x01\n\x0b\n\x03\
    \x04\x19\x01\x12\x04\xb8\x01\x08\x20\n\x0c\n\x04\x04\x19\x02\0\x12\x04\
    \xb9\x01\x04\x18\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xb9\x01\x04\n\n\r\n\
    \x05\x04\x19\x02\0\x01\x12\x04\xb9\x01\x0b\x13\n\r\n\x05\x04\x19\x02\0\
    \x03\x12\x04\xb9\x01\x16\x17\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xba\x01\
    \x04\x17\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xba\x01\x04\t\n\r\n\x05\
    \x04\x19\x02\x01\x01\x12\x04\xba\x01\n\x12\n\r\n\x05\x04\x19\x02\x01\x03\
    \x12\x04\xba\x01\x15\x16\n\x0c\n\x02\x04\x1a\x12\x06\xbd\x01\0\xbf\x01\
    \x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xbd\x01\x08!\n\x0c\n\x04\x04\x1a\
    \x02\0\x12\x04\xbe\x01\x04\x17\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xbe\
    \x01\x04\n\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xbe\x01\x0b\x12\n\r\n\x05\
    \x04\x1a\x02\0\x03\x12\x04\xbe\x01\x15\x16\n\x0c\n\x02\x04\x1b\x12\x06\
    \xc1\x01\0\xc3\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xc1\x01\x08\x20\n\
    \x0c\n\x04\x04\x1b\x02\0\x12\x04\xc2\x01\x04\x18\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\xc2\x01\x04\n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xc2\x01\
    \x0b\x13\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xc2\x01\x16\x17\n\x0c\n\x02\
    \x04\x1c\x12\x06\xc5\x01\0\xc7\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\
    \xc5\x01\x08!\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xc6\x01\x040\n\r\n\x05\
    \x04\x1c\x02\0\x04\x12\x04\xc6\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\0\x06\
    \x12\x04\xc6\x01\r\x1f\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xc6\x01\x20+\
    \n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xc6\x01./\n\x0c\n\x02\x04\x1d\x12\
    \x06\xc9\x01\0\xce\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xc9\x01\x08\
    \x20\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xca\x01\x04\x18\n\r\n\x05\x04\x1d\
    \x02\0\x05\x12\x04\xca\x01\x04\n\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xca\
    \x01\x0b\x13\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xca\x01\x16\x17\n\x0c\n\
    \x04\x04\x1d\x02\x01\x12\x04\xcb\x01\x04\x13\n\r\n\x05\x04\x1d\x02\x01\
    \x05\x12\x04\xcb\x01\x04\t\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xcb\x01\
    \n\x0e\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xcb\x01\x11\x12\n8\n\x04\
    \x04\x1d\x02\x02\x12\x04\xcc\x01\x04\x15\"*\x20TODO\x20(Andrew):\x20dete\
    rmine\x20how\x20/\x20if\x20to\x20use\n\n\r\n\x05\x04\x1d\x02\x02\x05\x12\
    \x04\xcc\x01\x04\n\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xcc\x01\x0b\x10\
    \n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xcc\x01\x13\x14\n\x0c\n\x04\x04\
    \x1d\x02\x03\x12\x04\xcd\x01\x04\x17\n\r\n\x05\x04\x1d\x02\x03\x05\x12\
    \x04\xcd\x01\x04\n\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xcd\x01\x0b\x12\
    \n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xcd\x01\x15\x16\n\x0c\n\x02\x04\
    \x1e\x12\x06\xd0\x01\0\xd2\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xd0\
    \x01\x08!\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xd1\x01\x040\n\r\n\x05\x04\
    \x1e\x02\0\x04\x12\x04\xd1\x01\x04\x0c\n\r\n\x05\x04\x1e\x02\0\x06\x12\
    \x04\xd1\x01\r\x1f\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xd1\x01\x20+\n\r\
    \n\x05\x04\x1e\x02\0\x03\x12\x04\xd1\x01./b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
